<!DOCTYPE html>

<html>

<head>
	<title>3D - DC</title>

	<link rel="stylesheet" type="text/css" href="css/styles.css" />

	<script type="text/javascript" src="js/three.js"></script>
	<script type="text/javascript" src="js/stats.js"></script>
	<script type="text/javascript" src="../physi.js"></script>
	<script type="text/javascript" src="js/orbitControl.js"></script>

	<script type="text/javascript" src="demo/data/data.js"></script>
	<script type="text/javascript" src="demo/objects/baseEntity.js"></script>
	<script type="text/javascript" src="demo/objects/server.js"></script>
	<script type="text/javascript" src="demo/objects/vm.js"></script>
	<script src="http://code.jquery.com/jquery-1.11.0.min.js" type="text/javascript" charset="utf-8"></script>
	<script type="text/javascript" src="demo/services/inventoryBuilder.js"></script>

	<script type="x-shader/x-vertex" id="vertexShader">

			varying vec3 vWorldPosition;

			void main() {

				vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
				vWorldPosition = worldPosition.xyz;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

	<script type="x-shader/x-fragment" id="fragmentShader">

			uniform vec3 topColor;
			uniform vec3 bottomColor;
			uniform float offset;
			uniform float exponent;

			varying vec3 vWorldPosition;

			void main() {

				float h = normalize( vWorldPosition + offset ).y;
				gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h, 0.0 ), exponent ), 0.0 ) ), 1.0 );

			}

		</script>


	<script type="text/javascript">

	'use strict';
	Physijs.scripts.worker = '../physijs_worker.js';
	Physijs.scripts.ammo = 'examples/js/ammo.js';
	var shouldZoom = true;
	var initScene, initEventHandling, render, craeateInventory, loader,
		renderer, render_stats, physics_stats, scene, controls,backgroundScene, backgroundCamera, dir_light, am_light, camera,
		table, vms = [], table_material, block_material, intersect_plane,
		selected_block = null, mouse_position = new THREE.Vector3, block_offset = new THREE.Vector3, _i, _v3 = new THREE.Vector3;

	initScene = function() {
		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.shadowMap.enabled = true;
		renderer.shadowMapSoft = true;
		renderer.setClearColor('#99ccff');


		document.getElementById( 'viewport' ).appendChild( renderer.domElement );
		/**

		 **/
		// Load the background texture
		var texture = THREE.ImageUtils.loadTexture( 'images/3dAwakens.png' );
		var backgroundMesh = new THREE.Mesh(
				new THREE.PlaneGeometry(2, 2, 0),
				new THREE.MeshBasicMaterial({
					map: texture
				}));

		backgroundMesh .material.depthTest = false;
		backgroundMesh .material.depthWrite = false;

		// Create your background scene
		backgroundScene = new THREE.Scene();
		backgroundCamera = new THREE.Camera();
		backgroundScene.add(backgroundCamera );
		backgroundScene.add(backgroundMesh );

		render_stats = new Stats();
		render_stats.domElement.style.position = 'absolute';
		render_stats.domElement.style.top = '1px';
		render_stats.domElement.style.zIndex = 100;
		document.getElementById( 'viewport' ).appendChild( render_stats.domElement );

		physics_stats = new Stats();
		physics_stats.domElement.style.position = 'absolute';
		physics_stats.domElement.style.top = '50px';
		physics_stats.domElement.style.zIndex = 100;
		document.getElementById( 'viewport' ).appendChild( physics_stats.domElement );

		scene = new Physijs.Scene({ fixedTimeStep: 1 / 120 });
		scene.setGravity(new THREE.Vector3( 0, -30, 0 ));
		scene.addEventListener(
			'update',
			function() {

				if ( selected_block !== null ) {

					_v3.copy( mouse_position ).add( block_offset ).sub( selected_block.position ).multiplyScalar( 5 );
					_v3.y = 0;
					selected_block.setLinearVelocity( _v3 );

					// Reactivate all of the vms
					_v3.set( 0, 0, 0 );
					for ( _i = 0; _i < vms.length; _i++ ) {
						vms[_i].applyCentralImpulse( _v3 );
					}
				}

				scene.simulate( undefined, 1 );
				physics_stats.update();
			}
		);




		camera = new THREE.PerspectiveCamera(
			35,
			window.innerWidth / window.innerHeight,
			1,
			1000
		);
		camera.position.set( 180, 180, 180 );
		camera.lookAt(new THREE.Vector3( 0, 7, 0 ));
		var controls = new THREE.OrbitControls( camera, renderer.domElement );
		controls.target.set( 0, 0, 0 ); // view direction perpendicular to XY-plane
		controls.enableRotate = true;
		controls.enableZoom = true; // optional
		scene.add( camera );

		// ambient light
		am_light = new THREE.AmbientLight( 0x444444 );
		scene.add( am_light );

		// directional light
		dir_light = new THREE.DirectionalLight( 0xFFFFFF );
		dir_light.position.set( 20, 30, 10 );
		dir_light.target.position.copy( scene.position );
		dir_light.castShadow = true;
		dir_light.shadowCameraLeft = -30;
		dir_light.shadowCameraTop = -30;
		dir_light.shadowCameraRight = 30;
		dir_light.shadowCameraBottom = 30;
		dir_light.shadowCameraNear = 20;
		dir_light.shadowCameraFar = 200;
		dir_light.shadowBias = -.001;
		dir_light.shadowMapWidth = dir_light.shadowMapHeight = 2048;
		dir_light.shadowDarkness = .5;
		scene.add( dir_light );

		// SKYDOME

		var vertexShader = document.getElementById( 'vertexShader' ).textContent;
		var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
		var uniforms = {
			topColor: 	 { type: "c", value: new THREE.Color( 0x0077ff ) },
			bottomColor: { type: "c", value: new THREE.Color( 0xffffff ) },
			offset:		 { type: "f", value: 400 },
			exponent:	 { type: "f", value: 0.6 }
		};
		uniforms.topColor.value.copy( dir_light.color );

		var skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );
		var skyMat = new THREE.ShaderMaterial( {
			uniforms: uniforms,
			vertexShader: vertexShader,
			fragmentShader: fragmentShader,
			side: THREE.BackSide
		} );

		var sky = new THREE.Mesh( skyGeo, skyMat );
		scene.add( sky );

		function buildAxes( length ) {
			var axes = new THREE.Object3D();

			axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( length, 0, 0 ), 0xFF0000, false ) ); // +X
			axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, true) ); // -X
			axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, length, 0 ), 0x00FF00, false ) ); // +Y
			axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, true ) ); // -Y
			axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, length ), 0x0000FF, false ) ); // +Z
			axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z

			return axes;

		}

		function buildAxis( src, dst, colorHex, dashed ) {
			var geom = new THREE.Geometry(),
					mat;

			if(dashed) {
				mat = new THREE.LineDashedMaterial({ linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3 });
			} else {
				mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex });
			}

			geom.vertices.push( src.clone() );
			geom.vertices.push( dst.clone() );
			geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

			return new THREE.Line(geom, mat, THREE.LinePieces);

		}

		scene.add(buildAxes(1000));

		// Loader
		loader = new THREE.TextureLoader();

		// Materials
		table_material = Physijs.createMaterial(
			new THREE.MeshLambertMaterial({ map: loader.load( 'images/vmPattern.jpg' )}),
			.9, // high friction
			.2 // low restitution
		);
		table_material.map.wrapS = table_material.map.wrapT = THREE.RepeatWrapping;
		table_material.map.repeat.set( 5, 5 );

		block_material = Physijs.createMaterial(
			new THREE.MeshLambertMaterial({ map: loader.load( 'images/wood.jpg' )}),
			.4, // medium friction
			.4 // medium restitution
		);
		block_material.map.wrapS = block_material.map.wrapT = THREE.RepeatWrapping;
		block_material.map.repeat.set( 1, .5 );

		// Table
		table = new Physijs.BoxMesh(
			new THREE.BoxGeometry(50, 1, 50),
			table_material,
			0, // mass
			{ restitution: .2, friction: .8 }
		);
		table.position.y = -.5;
		table.receiveShadow = true;
		scene.add( table );

		craeateInventory();

		intersect_plane = new THREE.Mesh(
			new THREE.PlaneGeometry( 150, 150 ),
			new THREE.MeshBasicMaterial({ opacity: 0, transparent: true })
		);
		intersect_plane.rotation.x = Math.PI / -2;
		scene.add( intersect_plane );
		scene.fog = new THREE.FogExp2( 0x99ccff, 0.007 );
		renderer.setClearColor( scene.fog.color, 1 );

		initEventHandling();

		requestAnimationFrame( render );
		scene.simulate();
	};

	render = function() {
		if(shouldZoom){
			camera.position.set( camera.position.x - 2, camera.position.y - 2, camera.position.z - 2);
			if(camera.position.x < 25){
				shouldZoom = false;
			}
		}
		requestAnimationFrame( render );
		renderer.autoClear = false;
		renderer.clear();
		//renderer.render(backgroundScene , backgroundCamera );
		renderer.render( scene, camera );
		render_stats.update();
	};

	craeateInventory = (function() {
		var block_height = 1, block_offset = 2;
		return function() {
			var i, j, rows = 16,
				block;
			InventoryBuilder.buildWorld({
				scene:scene,
				vms: vms
			});
			var server = new Server({name:"test"});
			server.position.y = 3;
			server.position.x = 3;
			//vms.push(server);
			//scene.add( server );
			for ( i = 0; i < rows; i++ ) {
				for ( j = 0; j < 3; j++ ) {
					block = new VM({name:"test"});
					block.position.y = (block_height / 2) + block_height * i;
					if ( i % 2 === 0 ) {
						block.rotation.y = Math.PI / 2.01; // #TODO: There's a bug somewhere when this is to close to 2
						block.position.x = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
					} else {
						block.position.z = block_offset * j - ( block_offset * 3 / 2 - block_offset / 2 );
					}
					block.receiveShadow = true;
					block.castShadow = true;
					//scene.add( block );
					vms.push( block );
				}
			}
		}
	})();


	initEventHandling = (function() {
		var _vector = new THREE.Vector3,
			handleMouseDown, handleMouseMove, handleMouseUp;

		handleMouseDown = function( evt ) {
			var ray, intersections;

			_vector.set(
				( evt.clientX / window.innerWidth ) * 2 - 1,
				-( evt.clientY / window.innerHeight ) * 2 + 1,
				1
			);

			_vector.unproject( camera );

			ray = new THREE.Raycaster( camera.position, _vector.sub( camera.position ).normalize() );
			intersections = ray.intersectObjects( vms );

			if ( intersections.length > 0 ) {
				selected_block = intersections[0].object;

				_vector.set( 0, 0, 0 );
				selected_block.setAngularFactor( _vector );
				selected_block.setAngularVelocity( _vector );
				selected_block.setLinearFactor( _vector );
				selected_block.setLinearVelocity( _vector );
				//selected_block._physijs.mass = 50;
				controls.enableRotate = false;
				//selected_block.setMass(30);
				mouse_position.copy( intersections[0].point );
				block_offset.subVectors( selected_block.position, mouse_position );

				intersect_plane.position.y = mouse_position.y;
			}
		};

		handleMouseMove = function( evt ) {

			var ray, intersection,
				i, scalar;

			if ( selected_block !== null ) {

				_vector.set(
					( evt.clientX / window.innerWidth ) * 2 - 1,
					-( evt.clientY / window.innerHeight ) * 2 + 1,
					1
				);
				_vector.unproject( camera );

				ray = new THREE.Raycaster( camera.position, _vector.sub( camera.position ).normalize() );
				intersection = ray.intersectObject( intersect_plane );
				mouse_position.copy( intersection[0].point );
			}

		};

		handleMouseUp = function( evt ) {
			controls.enableRotate = true;
			if ( selected_block !== null ) {
				_vector.set( 1, 1, 1 );
				selected_block.setAngularFactor( _vector );
				selected_block.setLinearFactor( _vector );

				selected_block = null;
			}

		};

		return function() {
			renderer.domElement.addEventListener( 'mousedown', handleMouseDown );
			renderer.domElement.addEventListener( 'mousemove', handleMouseMove );
			renderer.domElement.addEventListener( 'mouseup', handleMouseUp );
		};
	})();

	window.onload = initScene;

	</script>





</head>

<body>
	<div id="viewport"></div>

	<div id="addVmDiv">
		<p>Add a VM</p>
		<input type="button" name="addVm" value="+" class="addVm">

		<ul id="vmList">
			<li>template vm1</li>
			<li>template vm2</li>
			<li>template vm3</li>
		</ul>
	</div>

	<div id="addVmForm">
		<h2>create a VM template</h2>
		<form>
			VM name: <input type="text" name="vmName">
			<br><br>
			cpu:<input type="text" name="cpu">
			<br><br>
			memory:<input type="text" name="memory">
		</form>
		<br>
		<br>
		<button id="addVmButton">Add</button>
		<button id="cancelAddVmButton">Cancel</button>
	</div>

	<script type="text/javascript">
		$(function () {
			var clicked = false;
			$("#vmList li").hide();
			$("#addVmForm").hide();

			$("ul").delegate( "li", "click", function() {
				var vmName = $(this).text();
				var vm = new VM({name: vmName});
				var position = getAvailableVmPosition();
				vm.position.y = position[0];
				vm.position.x = position[1];
				scene.add(vm);
			});

			$("#addVmDiv input").click(function () {
				clicked = true;
				$("#vmList li").show();
				$("#addVmForm").show();
			});

			$("#addVmButton").click(function () {
				$("#addVmForm").show();
				var vmName = $('input[name="vmName"]').val();
				$("#vmList").append('<li>' + vmName + '</li>');
				$("#addVmForm").hide();
				clicked = false;
				$("#vmList li").slideUp(3500);

			});
			$("#cancelAddVmButton").click(function () {
				clicked = false;
				$("#addVmForm").hide();
				$("#vmList li").slideUp(1500);
			});

			$("#addVmDiv").hover(function () {
				$("#vmList li").show(800);
			}).mouseleave(function (){
				if (!clicked){
					$("#vmList li").slideUp(1500);
				}
			});

			var getAvailableVmPosition = function(){
				//find an a available spot on a server and
				//return it's x,y
				return [8,8];
			}

		});
	</script>

</body>

</html>
